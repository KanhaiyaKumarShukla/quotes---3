
-------------------------------------------------------------  *** Gson *** ------------------------------------------------------------------------
refer: - https://futurestud.io/tutorials/gson-builder-basics-naming-policies




------------------------------------------------------------  *** Retrofit *** ----------------------------------------------------------------------

* Reference :- https://futurestud.io/tutorials/retrofit-2-basics-of-api-description

* API Endpoints :- It is a URL use to access data from API. When you want to interact with the API, you "order" a specific service or data by accessing the corresponding endpoint. you tell the API
       which endpoint you want to access by sending a request to its specific URL.
       Imagine an API like a menu at a restaurant. Each item on the menu represents a different dish you can order. Similarly, each API endpoint is like an item on the menu, representing a different
       service or piece of data that the API can provide.
       By accessing these endpoints with appropriate HTTP requests (such as GET, POST, PUT, DELETE), developers can integrate the APIs functionality into their applications.

* Retrofit is a open source library, use for making HTTP requests to web services and APIs. Retrofit serves as an HTTP client for making network requests from your Android app.
       Retrofit integrates with other libraries like Gson or Jackson for serialization and deserialization of JSON data.


*** Retrofit is implemented similar to room database , where entity class is replaced by data class, DAO is replaced by API interface and database class is replaced by Build Retrofit Object.
    To implement retrofit : 1. data class ,   2. API Interface   and     3. Retrofit Object.

step - 1 : data class can be generated by any plugin like: "JSON to Kotlin class".
step-2 : make a interface "QuoteAPI". Define methods which will return the "Response" object. Response is a generic class provided by Retrofit to encapsulate an HTTP response. It is used to wrap the
         HTTP response received from the server. Each method in the interface represents a specific API endpoint, with annotations provided by Retrofit to specify details like the URL path,
         query parameters, request body, etc. Every method must have an HTTP annotation that provides the request method and relative URL. There are eight built-in annotations: HTTP, GET, POST,
         PUT, PATCH, DELETE, OPTIONS and HEAD. The relative URL of the resource (endpoint) is specified in the annotation. eg. @GET("users/list")

         annotations are :
         1. @Query: when you want to add query parameters to your URL. Query parameters are appended to the URL with a '?' separator. For ex, if you have an endpoint like '/search' and parameters
         like "query" and "page", you would use @Query for each parameter:
         @GET("/search")
         suspend fun search(@Query("query") query: String, @Query("page") page: Int): Response

         2. @Path: when you want to substitute parts of the URL path with dynamic values. For ex, if you have an endpoint like "/users/{id}" where {id} is a dynamic value representing a user's ID,
         use @Path to specify the ID:
         @GET("/users/{id}")
         suspend fun getUser(@Path("id") userId: String): Response<User>.
         The value passed to @Path will be substituted into the URL at runtime.

         3. @QueryMap: when you want to pass multiple query parameters as a map, when the number of query parameters is not known beforehand or when you want to pass a dynamic set of parameters.
         For example: @GET("/search")
                     suspend fun search(@QueryMap options: Map<String, String>): Response<List<Result>>.


 step-3 : To create a network requests to a REST API with Retrofit, we need to create an instance using the " Retrofit.Builder " class and configure it with a base URL. When you instantiate Retrofit,
         you're creating an instance of this class, which acts as a client for making API calls.

         *** Retrofit.Builder :-
          * Initialisation : val builder = Retrofit.Builder()
          * set base URL for API endpoints using baseURL() :  builder.baseUrl("https://api.example.com/");
          * Retrofit needs a converter factory to serialize and deserialize HTTP request and response bodies. You can add a converter factory using the addConverterFactory() method:
            builder.addConverterFactory(GsonConverterFactory.create());                   //Retrofit provides GsonConverterFactory.
          * we can customize retrofit feature by adding other options such as call adapters, HTTP client, etc. " client(client: OkHttpClient) ": Sets the HTTP client to be used for making HTTP requests.
            Retrofit typically uses OkHttp as its default HTTP client, but you can provide a custom OkHttpClient instance if needed. ex.- "OkHttpClient" is a popular HTTP client library .
                  val httpClient = OkHttpClient.Builder().build()               // make a instance of OKHttpClient.
                  builder.client(httpClient)
          * After configuring Retrofit with the desired options, you call the build() method to create the final Retrofit instance: val retrofit = builder.build()

          ex. -
          val retrofit = Retrofit.Builder()
              .baseUrl("https://api.example.com/")                                     // add BaseUrl.
              .addConverterFactory(GsonConverterFactory.create())                     // add gson converter factory.
              .build()                                                               // Create Retrofit instance

         Now at this stage we have a instance of retrofit.

 step -4 : Final step- Inside the onCreate() method of the MainActivity.java, we initialise an instance of the RetrofitClient using " retrofit.create(ApiService::class.java) ". It is used to create
         instances of API service interfaces. This method is crucial for transforming your API interface into a callable object that can be used to make network requests. It takes the interface
         class as its argument and returns an instance of that interface.
         eg.- val apiService = retrofit.create(ApiService::class.java)

         Now make network request by calling the methods defined in API interface (step-2) to to fetch a data with the specified parameter. Retrofit handles the HTTP communication, and the response
         is automatically serialized into object based on the JSON structure returned by the server.
         ex. -
         interface ApiService {
             @GET("/posts/{id}")
             suspend fun getPostById(@Path("id") postId: Int): Post
         }
         val post = apiService.getPostById(1)                  // it return response, getPostById() is defined in API interface.

          When the HTTP request is complete, Retrofit receives the response from the server. The response is encapsulated in a Response object, which contains information such as the HTTP status code,
          response headers, and the response body. Method use to access response data are:
          1. body(): This method returns the deserialized response body. It extracts the response body from the Response object and automatically converts it into the specified type using the
                     configured converter factories.
                     eg.- val result = response.body()

          2. headers(): This method returns the response headers as an instance of Headers. You can use methods like get(), size(), and names() on the Headers object to access individual headers.
                     eg.-  Headers headers = response.headers();
                           String contentType = headers.get("Content-Type");

          3. errorBody(): This method returns the error response body if the HTTP request was not successful (i.e., if the status code is not in the range 200-299). It returns null if the request
                     was successful.
                     eg.- if (!response.isSuccessful()) {
                              // Handle error response
                              ResponseBody errorBody = response.errorBody();
                              // Process the error body, if needed
                          }

          and many more.

         we call these response method in coroutine, to avoid main thread block.



         -------------------------------------------------------------------------*** Call Object ***--------------------------------------------------------------------
         If you want to make synchronous requests and handle the response directly within the calling thread, you should use Response in API interface. Synchronous requests are suitable for
         background tasks or situations where you want to block the current thread until the request completes.
         But, Asynchronous requests are often preferred in Android applications to prevent blocking the main UI thread. We do this using "Call" instead of Response. It is used in long-running apps.
         When you make an asynchronous request using Retrofit, you provide a callback object that Retrofit invokes when the request completes or encounters an error. This mechanism provides a way
         to execute code asynchronously in response to network operations.

         Retrofit defines a Callback<T> interface for handling asynchronous responses.  This interface contains two methods: onResponse() and onFailure().
         * onResponse():This method is called when the HTTP request is successful and a response is received from the server. It passes the response object containing the deserialized response body.

         * onFailure(): This method is called when the HTTP request fails, either due to a network error, server error, or other reasons. It passes an instance of Throwable representing the error.

         To handle asynchronous responses, you implement the Callback<T> interface and override its methods to define your response handling logic.
         Implementation of Call :-
         1. data class is same as response.
         2. we use Call instead of Response in API interface.
         eg.-  interface GitHubClient {
                   @GET("/users/{user}/repos")
                   fun reposForUser( @Path("user") user: String ): Call<List<GitHubRepo>>
               }

         3. same as response.
         4. In mainActivity, create instance of RetrofitClient or API interface similar to response which is used to make network call. And then call the method defined in interface for network connection.
            val service = RetrofitClientInstance.getRetrofitInstance().create(GetDataService.class)
            val call: Call<List<GitHubRepo>> = service.getAllPhotos()
         Now Implement the Callback<T> interface and override its methods to define your response handling logic:
         eg.-       call.enqueue(object : Callback<List<GitHubRepo>> {
                         override fun onResponse(call: Call<List<GitHubRepo>>, response: Response<List<GitHubRepo>>) {
                             if (response.isSuccessful) {
                                 val post = response.body()
                                 // Handle the retrieved post data
                             } else {
                                 // Handle error
                             }
                         }

                         override fun onFailure(call: Call<List<GitHubRepo>>, t: Throwable) {
                             // Handle failure
                         }
                     })




         Reference : https://medium.com/@imkuldeepsinghrai/api-calls-with-retrofit-in-android-kotlin-a-comprehensive-guide-e049e19deba9







